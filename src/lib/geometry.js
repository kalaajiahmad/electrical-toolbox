export function clientToCanvasPoint(clientX, clientY, zoom, pan){ return { x:(clientX - pan.x)/zoom, y:(clientY - pan.y)/zoom } }
export function getCanvasCenter(el, zoom, pan){ if(!el) return { x:0, y:0 }; const rect = el.getBoundingClientRect(); return clientToCanvasPoint(rect.left + rect.width/2, rect.top + rect.height/2, zoom, pan) }
export function calcAllPortPositions(nodes){ const map = new Map(); nodes.forEach(n => { n.ports.forEach((p, idx) => { const pp = portPositionForNode(n, p, idx); map.set(`${n.id}:${p.id}`, { x:n.x + pp.x, y:n.y + pp.y }) }) }); return map }
export function portPositionForNode(node, port, idx){ const pad=10, spacing=18; const countSide=(side)=> node.ports.filter(p=>p.side===side).length; const orderOnSide=(side,p,i)=>{ let k=-1, c=0; for(let j=0;j<node.ports.length;j++){ if(node.ports[j].side===side){ if(j===i){k=c;break;} c++; } } return k }; const iOnSide = orderOnSide(port.side,port,idx); const nOnSide = countSide(port.side); const offset = (iOnSide - (nOnSide - 1)/2)*spacing; switch(port.side){ case 'left': return { x:0-pad, y: node.h/2 + offset }; case 'right': return { x: node.w+pad, y: node.h/2 + offset }; case 'top': return { x: node.w/2 + offset, y: 0-pad }; case 'bottom': return { x: node.w/2 + offset, y: node.h+pad }; default: return { x:0, y:0 } } }
export function makePath(a,b){ const dx = Math.abs(b.x - a.x); const c1x = a.x + Math.max(40, dx/3); const c2x = b.x - Math.max(40, dx/3); return `M ${a.x} ${a.y} C ${c1x} ${a.y}, ${c2x} ${b.y}, ${b.x} ${b.y}` }
